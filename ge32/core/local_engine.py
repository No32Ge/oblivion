import subprocess
import sys
import uuid
from pathlib import Path

from auto_费.core.sandbox import ExecutionSandbox
from auto_费.templates.program_templates import PROGRAM_TEMPLATES
from auto_费.utils.file_utils import FILE_CREATION_PATTERN, create_files
from auto_test.utils.file_utils import save_file


class LocalProgramEngine:
    def __init__(self):
        self.program_dir = "local_programs"
        self.create_file_dir = "docs/"
        self.template_cache = {}

    def create_program(self, program_name, code, dependencies=None):
        """创建可执行的本地程序"""
        program_path = Path(self.program_dir) / f"{program_name}.py"

        # 添加标准头部
        full_code = f"""#!/usr/bin/env python3
                        # Auto-generated by DeepMindBot
                        {code}
                        """
        save_file(full_code, self.program_dir, f"{program_name}.py")
        program_path.chmod(0o755)  # 添加可执行权限

        if dependencies:
            self._install_dependencies(dependencies)

        return str(program_path)

    def execute_program(self, program_path, args=None):
        """执行本地程序"""
        cmd = [sys.executable, program_path]
        if args:
            cmd.extend(args)

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True
        )
        return {
            "exit_code": result.returncode,
            "output": result.stdout,
            "error": result.stderr
        }

    def _install_dependencies(self, packages):
        """自动安装依赖"""
        subprocess.run([sys.executable, "-m", "pip", "install"] + packages)

    ####### 新加
    def process_creation_commands(self, command_str: str) -> str:
        """新增到现有类中"""

        structures = []
        for match in FILE_CREATION_PATTERN.finditer(command_str):
            groups = match.groupdict()
            structures.append({
                'path': self.create_file_dir+groups['path'],
                'content': groups['content'] or '',
                'overwrite': groups.get('overwrite', 'False') == 'True'
            })

        if not structures:
            return "未检测到有效创建指令"

        return "\n".join(create_files(structures))

    def execute_template(self, template_name, params):
        # 1. 安全加载模板（只读模式）
        template = PROGRAM_TEMPLATES.get(template_name)
        if not template:
            return {"error": "Template not found"}

        # 2. 生成临时执行文件（确保路径唯一）
        temp_path = f"./temp/{template_name}_{uuid.uuid4()}.py"
        with open(temp_path, "x") as f:  # 'x'模式防止覆盖
            f.write(template["template"])

        # 3. 选择执行环境
        if template.get("needs_sandbox"):
            return ExecutionSandbox().safe_execute(temp_path)
        else:
            return self.execute_program(temp_path)

    def execute_program_no_wait(self, program_path, args=None):
        cmd = [sys.executable, program_path]
        if args:
            cmd.extend(args)

        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        return {
            "process": process
        }

    def execute_template_with(self, template_name, params):
        # 1. 安全加载模板（只读模式）
        template = PROGRAM_TEMPLATES.get(template_name)
        if not template:
            return {"error": "Template not found"}

        # 2. 生成临时执行文件（确保路径唯一）
        temp_path = f"./temp/{template_name}_{uuid.uuid4()}.py"
        with open(temp_path, "x") as f:
            f.write(template["template"])

        # 3. 构建命令行参数
        args = []
        if params:
            for key, value in params.items():
                args.append(f"--{key}")
                args.append(str(value))

        # 4. 选择执行环境
        if template.get("needs_sandbox"):
            return ExecutionSandbox().safe_execute(temp_path)
        else:
            return self.execute_program_no_wait(temp_path, args)




